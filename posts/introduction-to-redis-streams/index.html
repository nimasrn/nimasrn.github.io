<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introduction to Redis Streams | Nimasrn</title><meta name=keywords content><meta name=description content="Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn&rsquo;t confused up they are two different things."><meta name=author content><link rel=canonical href=https://nimasrn.github.io/posts/introduction-to-redis-streams/><link crossorigin=anonymous href=https://nimasrn.github.io/assets/css/stylesheet.min.b15591da31b4f827d6dc0b97cf931d21b01610305321ac220bf755cf6aade94e.css integrity="sha256-sVWR2jG0+CfW3AuXz5MdIbAWEDBTIawiC/dVz2qt6U4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://nimasrn.github.io/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://nimasrn.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nimasrn.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nimasrn.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nimasrn.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nimasrn.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="Introduction to Redis Streams"><meta property="og:description" content="Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn&rsquo;t confused up they are two different things."><meta property="og:type" content="article"><meta property="og:url" content="https://nimasrn.github.io/posts/introduction-to-redis-streams/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-25T13:22:34+04:30"><meta property="article:modified_time" content="2021-05-25T13:22:34+04:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Introduction to Redis Streams"><meta name=twitter:description content="Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn&rsquo;t confused up they are two different things."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nimasrn.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Introduction to Redis Streams","item":"https://nimasrn.github.io/posts/introduction-to-redis-streams/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introduction to Redis Streams","name":"Introduction to Redis Streams","description":"Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn\u0026rsquo;t confused up they are two different things.","keywords":[],"articleBody":"Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn’t confused up they are two different things.\nRedis pub/sub and Redis Streams let’s have a short review on Redis pub/sub and learn the differences and benefits we get when we work with the streams. Redis incorporated the publish-subscribe pattern in version 2.0.0, which allows clients to subscribe to one or more channels and receive messages as long as they are connected. the publisher produces messages in a channel without knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more and only receive messages that are of interest and subscribed to, without knowledge of what (if any) publishers there are. there is no data safety in Redis pub/sub and a case of a network connection failure between a publisher and subscriber messages are gone be lost and by the time of reconnecting the messages in-between are lost forever and there is no acknowledgment system in order the consumer to ack the publisher which it had or hadn’t received the message. Actually, we could use lists or hashes to build a message queue that has data persistency and handle the data loss in Redis pub/sub pattern but its not the very right tool to do that and we miss a lot of amazing features because of the nature of pub/sub itself in Redis, so starting with version 5.0.0 you can use Streams, a new datatype implemented with a log data structure and a set of very flexible commands. in Redis streams, unlike pub/sub the order matters to us and keeps track of the message orders and the sequences without having to lock the database to write new data. also, it includes the concept of Consumer Groups and it help us to scale our consumers to not having any bottleneck. so let’s wrap it up these differences:\n  Redis pub/sub not handling’s the failures and data loss on the other hand thanks to the consumer and publisher pattern alongside the acknowledgment system that already exists in Redis Streams we never lose a message or task anymore.\n  Redis Streams will keep the data like a log file with sequence and others until we decided to clear it.\n  Redis Streams are append-only and we don’t need to lock the database for writing new data and we have some cool features like the time we write the data without the need to use any other things by just using auto-generated Id that is built-in.\n  Redis Streams have the concept of consumer groups and acknowledgment and it help us to scale easily and have more fail tolerance by adding more workers and consumers.\n  on the other hand, you should see Redis pub/sub more like protocol that can move your message around.\n  Streams basics Conceptually, a Stream in Redis is a list where you can append entries. Each entry has a unique ID and a value and a field name. the field and value must be a string. the ID is auto-generated by default and it includes a timestamp but it also could be custom with some pattern and rules to noticed.\nRedis Streams commnads  XACK removes one or multiple messages from the pending entries list (PEL) of a stream consumer group. XADD Appends the specified stream-entry to the stream at the specified key. XAUTOCLAIM transfers ownership of pending stream entries that match the specified criteria. XCLAIM changes the ownership of a pending message. XDEL Removes the specified entries from a stream. XGROUP manage the consumer groups associated with a stream data structure. XINFO retrieve different information about the streams and associated consumer groups. XLEN Returns the number of entries inside a stream. XPENDING inspect the list of pending messages. XRANGE returns the stream entries matching a given range of IDs. XREAD Read data from one or multiple streams. XREADGROUP a special version of the XREAD command with support for consumer groups. XREVRANGE returning the entries in reverse order. XTRIM trims the stream by evicting older entries.  ","wordCount":"730","inLanguage":"en","datePublished":"2021-05-25T13:22:34+04:30","dateModified":"2021-05-25T13:22:34+04:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://nimasrn.github.io/posts/introduction-to-redis-streams/"},"publisher":{"@type":"Organization","name":"Nimasrn","logo":{"@type":"ImageObject","url":"https://nimasrn.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://nimasrn.github.io accesskey=h title="Nimasrn (Alt + H)">Nimasrn</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Introduction to Redis Streams</h1><div class=post-meta>May 25, 2021</div></header><div class=post-content><p>Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building
stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to
startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of
Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn&rsquo;t
confused up they are two different things.</p><h2 id=redis-pubsub-and-redis-streams>Redis pub/sub and Redis Streams<a hidden class=anchor aria-hidden=true href=#redis-pubsub-and-redis-streams>#</a></h2><p>let’s have a short review on Redis pub/sub and learn the differences and benefits we get when we work with the streams.
Redis incorporated the publish-subscribe pattern in version 2.0.0, which allows clients to subscribe to one or more
channels and receive messages as long as they are connected. the publisher produces messages in a channel without
knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more and only receive
messages that are of interest and subscribed to, without knowledge of what (if any) publishers there are. there is no
data safety in Redis pub/sub and a case of a network connection failure between a publisher and subscriber messages are
gone be lost and by the time of reconnecting the messages in-between are lost forever and there is no acknowledgment
system in order the consumer to ack the publisher which it had or hadn’t received the message. Actually, we could use
lists or hashes to build a message queue that has data persistency and handle the data loss in Redis pub/sub pattern but
its not the very right tool to do that and we miss a lot of amazing features because of the nature of pub/sub itself in
Redis, so starting with version 5.0.0 you can use Streams, a new datatype implemented with a log data structure and a
set of very flexible commands. in Redis streams, unlike pub/sub the order matters to us and keeps track of the message
orders and the sequences without having to lock the database to write new data. also, it includes the concept of
Consumer Groups and it help us to scale our consumers to not having any bottleneck. so let&rsquo;s wrap it up these
differences:</p><ol><li><p>Redis pub/sub not handling’s the failures and data loss on the other hand thanks to the consumer and publisher
pattern alongside the acknowledgment system that already exists in Redis Streams we never lose a message or task
anymore.</p></li><li><p>Redis Streams will keep the data like a log file with sequence and others until we decided to clear it.</p></li><li><p>Redis Streams are append-only and we don’t need to lock the database for writing new data and we have some cool
features like the time we write the data without the need to use any other things by just using auto-generated Id
that is built-in.</p></li><li><p>Redis Streams have the concept of consumer groups and acknowledgment and it help us to scale easily and have more fail
tolerance by adding more workers and consumers.</p></li><li><p>on the other hand, you should see Redis pub/sub more like protocol that
can move your message around.</p></li></ol><h2 id=streams-basics>Streams basics<a hidden class=anchor aria-hidden=true href=#streams-basics>#</a></h2><p>Conceptually, a Stream in Redis is a list where you can append entries. Each entry has a unique ID and a value and a field name. the field and value must be a string. the ID is auto-generated by default and it includes a timestamp but it also could be custom with some pattern and rules to noticed.</p><h2 id=redis-streams-commnads>Redis Streams commnads<a hidden class=anchor aria-hidden=true href=#redis-streams-commnads>#</a></h2><ul><li><code>XACK</code> removes one or multiple messages from the pending entries list (PEL) of a stream consumer group.</li><li><code>XADD</code> Appends the specified stream-entry to the stream at the specified key.</li><li><code>XAUTOCLAIM</code> transfers ownership of pending stream entries that match the specified criteria.</li><li><code>XCLAIM</code> changes the ownership of a pending message.</li><li><code>XDEL</code> Removes the specified entries from a stream.</li><li><code>XGROUP</code> manage the consumer groups associated with a stream data structure.</li><li><code>XINFO</code> retrieve different information about the streams and associated consumer groups.</li><li><code>XLEN</code> Returns the number of entries inside a stream.</li><li><code>XPENDING</code> inspect the list of pending messages.</li><li><code>XRANGE</code> returns the stream entries matching a given range of IDs.</li><li><code>XREAD</code> Read data from one or multiple streams.</li><li><code>XREADGROUP</code> a special version of the <code>XREAD</code> command with support for consumer groups.</li><li><code>XREVRANGE</code> returning the entries in reverse order.</li><li><code>XTRIM</code> trims the stream by evicting older entries.</li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://nimasrn.github.io>Nimasrn</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const d=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function c(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),c();return}const a=document.createRange();a.selectNodeContents(b);const d=window.getSelection();d.removeAllRanges(),d.addRange(a);try{document.execCommand('copy'),c()}catch(a){}d.removeRange(a)}),d.appendChild(a)})</script></body></html>