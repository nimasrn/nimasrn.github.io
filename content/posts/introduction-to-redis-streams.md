---
title: "Introduction to Redis Streams"
date: 2021-05-25T13:22:34+04:30 draft: false
---
Redis has introduced a new type of data structure in version 5.0.0, a significant data structure for building
stream-processing services and message queues like RabitMQ and Apache Kafka it gives you the most simple and powerful to
startup. Redis Streams are primarily an append-only data structure like writing a log file and unlike the nature of
Redis pub/sub, it cares a lot more about data loss by using consumer and consumer group patterns and you shouldn't
confused up they are two different things.

## Redis pub/sub and Redis Streams

let’s have a short review on Redis pub/sub and learn the differences and benefits we get when we work with the streams.
Redis incorporated the publish-subscribe pattern in version 2.0.0, which allows clients to subscribe to one or more
channels and receive messages as long as they are connected. the publisher produces messages in a channel without
knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more and only receive
messages that are of interest and subscribed to, without knowledge of what (if any) publishers there are. there is no
data safety in Redis pub/sub and a case of a network connection failure between a publisher and subscriber messages are
gone be lost and by the time of reconnecting the messages in-between are lost forever and there is no acknowledgment
system in order the consumer to ack the publisher which it had or hadn’t received the message. Actually, we could use
lists or hashes to build a message queue that has data persistency and handle the data loss in Redis pub/sub pattern but
its not the very right tool to do that and we miss a lot of amazing features because of the nature of pub/sub itself in
Redis, so starting with version 5.0.0 you can use Streams, a new datatype implemented with a log data structure and a
set of very flexible commands. in Redis streams, unlike pub/sub the order matters to us and keeps track of the message
orders and the sequences without having to lock the database to write new data. also, it includes the concept of
Consumer Groups and it help us to scale our consumers to not having any bottleneck. so let's wrap it up these
differences:

1. Redis pub/sub not handling’s the failures and data loss on the other hand thanks to the consumer and publisher
   pattern alongside the acknowledgment system that already exists in Redis Streams we never lose a message or task
   anymore.
2. Redis Streams will keep the data like a log file with sequence and others until we decided to clear it.
3. Redis Streams are append-only and we don’t need to lock the database for writing new data and we have some cool
   features like the time we write the data without the need to use any other things by just using auto-generated Id
   that is built-in.

4. Redis Streams have the concept of consumer groups and acknowledgment and it help us to scale easily and have more fail
tolerance by adding more workers and consumers. 
5. on the other hand, you should see Redis pub/sub more like protocol that
can move your message around.

## Streams basics

Conceptually, a Stream in Redis is a list where you can append entries. Each entry has a unique ID and a value and a field name. the field and value must be a string. the ID is auto-generated by default and it includes a timestamp but it also could be custom with some pattern and rules to noticed.

## Redis Streams commnads

- `XACK`  removes one or multiple messages from the pending entries list (PEL) of a stream consumer group.
- `XADD` Appends the specified stream-entry to the stream at the specified key.
- `XAUTOCLAIM` transfers ownership of pending stream entries that match the specified criteria.
- `XCLAIM` changes the ownership of a pending message.
- `XDEL` Removes the specified entries from a stream.
- `XGROUP` manage the consumer groups associated with a stream data structure.
- `XINFO` retrieve different information about the streams and associated consumer groups.
- `XLEN` Returns the number of entries inside a stream.
- `XPENDING` inspect the list of pending messages.
- `XRANGE` returns the stream entries matching a given range of IDs.
- `XREAD` Read data from one or multiple streams.
- `XREADGROUP` a special version of the `XREAD` command with support for consumer groups.
- `XREVRANGE` returning the entries in reverse order.
- `XTRIM` trims the stream by evicting older entries.
